## 1. 介绍

TLS协议的主要目标是保护两个应用之间传输数据的私密性和完整性。此协议由两层组成：TLS记录协议和TLS握手协议。最底层是构建于一些可靠传输协议（例如TCP）之上的TLS记录协议。TLS记录协议在两方面保证了连接的安全性：

- 连接是私密的。协议使用对称加密算法（例如AES，RC4等）加密数据。每个连接使用的对称加密的Key是唯一生成的，并且使用另一个协议（例如TLS握手协议）来加密传输。记录协议也可以不加密使用。

- 连接是可靠的。消息在传输过程中会使用keyed MAC进行完整性检验。MAC计算使用安全的hash函数（例如SHA-1等等）。记录协议操作可以没有MAC，但通常只有另一个协议正在使用记录协议进行安全参数的交换时使用这种模式。

TLS记录协议用于封装某些更高层次的协议。TLS握手协议就是这样一种封装后的协议，它允许服务端和客户端验证对方的真实性和在传输第一个字节的数据前交换加密算法和加密key。TLS握手协议在三个方面保证连接的安全性。

- 各端的身份使用非对称的或者公钥算法（例如RSA，DSA等等）进行真实性检验。这种身份校验是可选的，但通常至少一方需要进行这种校验。

- 协商共享秘钥的过程是安全的：交换的秘钥对窃听者是不可用的，且任何未识别的连接无法获取秘钥，即使是一个能够把自己放到连接之间的攻击者也无法获取。

- 协商的过程是可靠的：没有攻击者能够在不被连接各方侦察到的情况下修改协商通信。

TLS的一大优势是它独立于应用层协议，更高层的协议可以透明的构建在TLS之上。然而，TLS协议并不会指定如何用协议来增强安全性，如何初始化TLS握手和如何解析交换的身份认证证书依赖于协议的设计者和实现者去决断。

## 1.1. 需要知道的术语

此文档中的术语 “MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，"RECOMMENDED"，“MAY”和“OPTIONAL”在[RFC 2119](https://www.rfc-editor.org/rfc/rfc2119)中做了解释。

## 1.2. 和TLS1.1版的主要差异

此文档是TLS 1.1协议的修订版，提升了协议的灵活性，尤其是对加密算法的协商过程。主要的差异点有：

- MD5/SHA-1组合的伪随机数函数（PRF）已经被加密套件指定的PRFs替换。此文档中的所有加密套件都是使用P_SHA256。

- 数字签名元素中MD5/SHA-1的组合已经被一个单独的hash函数取代，签名元素现在包括一个字段明确指定所使用的hash算法。

- 大量削减客户端和服务端指定hash算法和签名算法的能力操作能够指定使用何种hash算法和签名算法。注意这样也会放开一些之前版本签名算法和hash算法的限制

- 增加更多的数据模式来支持基于身份验证的加密。

- 扩展的定义和AES加密套件从第三方（TLSEXT和TLSAES）合并过来。

- 更严格的检查EncryptedPreMaster的版本号。

- 一些要求更加的严格。

- 数据长度校验现在依赖于加密套件（默认的仍是 12）。

- 删除了对Bleichenbacher/Klima攻防的描述。

- 很多场景下现在必须发送报警。

- 证书请求发起之后，如果没有可用的证书，客户端必须发送一个空证书列表。

- 使用TLS_RSA_WITH_AES_128_CBC_SHA算法实现加密套件是现在的强制要求。

- 增加HMAC-SHA256加密套件

- 移除IDEA和DES加密套件。它们现在已经过时了，并且会在一个单独的文档中描述。

- 对SSLv2版hello的向后兼容现在是MAY而不是SHOULD，而发送SSLv2版hello现在是SHOULD NOT。对它的支持将来也可能会变成SHOULD NOT。

- 增加了限制性的“fall-through”语法到表现语言中以便允许不同的情况有相同的编码。

- 增加了一个实现危险系数的章节。

- 一般性的说明和编辑工作。

## 2. 协议的目标

TLS协议的目标，按优先级排序如下：

    1. 加密的安全性：TLS应该用于双方建立安全的连接。

    2. 互操作性：独立的程序员应该能够使用TLS来开发应用程序，并且在不知道另一个人的代码的前提下成功的能与之交换参数。

    3. 可扩展性：TLS寻求实现一种框架，以便需要时能够方便的添加进来新的公钥和批量加密方法。这包括实现两个子目标：防止产生创建新协议的需要（并冒着产生新缺陷的风险）和避免实现一个新的完整的安全库。

    4. 相对的高效：加密操作相对是高CPU密集型的工作，尤其是公钥加密。因此，TLS协议已经支持了一个可选的会话缓存机制来减少创建连接的次数。此外，我们还把关注点放到了减少网络事件上。

## 3. 此文档的目标

此文档和TLS协议本身基于由网景公司发布的SSL 3.0协议说明发展而来。此协议和SSL 3.0协议之间的差距并不显著，但是差异也足够让TLS和SSL 3.0之间无法互相兼容（尽管每种协议都支持降级到前一个版本的机制）。本文档主要面向想要实现协议的读者和对协议做加密分析的用户。此说明书也是用这种思路来编写，且打算实现两组人不同的需求。为此，很多算法相关的数据结构和规则正文中（和附录相对），提供了更加容易的访问方式。

此文档并不打算提供任何服务定义或接口定义相关的详情。尽管它的确包含了策略的选择，但这是保持健壮的安全性的需要。

## 4. 表示语言

此文档使用一种外部的表示法来表示数据格式。接下来这种非常基础和有点随意定义的表示法将会使用。这种语法在结构上有几种来源。尽管它在语法上和编程语言“C”很相似，在XDR上和“C”的语法和缩进都很相似，借鉴太多相似的东西可能是一个风险。这种表示语言的目的仅仅局限于TLS文档；并没有超出特定目标的一般性的应用。

## 4.1. 基础数据块大小

所有数据项的表示是明确指定的。基础的数据块大小是1字节（也就是8位）。多字节数据项由多字节来组合，从左至右，从上到下。在字节流中，一个多字节的数据项（以数字为例）组合如下（使用C表示）:
```c
value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) | ... | byte[n-1];
```

这种多字节值的字节序就是常见的网络字节序或者叫大端法。

## 4.2. 其他约定

注释以“/\*”开始和“\*/”结束。

可选的组成部分用双括号“[[]]”括住来表示。

单字节没有特定含义的实体被认为是不透明的数据类型。

## 4.3. 向量

向量（一维数组）是一系列同类型的数据的流。向量的大小可能在代码编写阶段指定也可能在运行阶段才指定。另一方面，长度是指向量中字节的数量，而不是元素的数量。指定一种固定长度的数据类型为T的向量T'的语法是：

```
T T'[n];
```

这里，T'占用数据流中的n个字节，n是类型T大小的倍数。向量的长度不包括在数据流编码中。
