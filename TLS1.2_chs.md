## 1. 介绍

TLS协议的主要目标是保护两个应用之间传输数据的私密性和完整性。此协议由两层组成：TLS记录协议和TLS握手协议。最底层是构建于一些可靠传输协议（例如TCP）之上的TLS记录协议。TLS记录协议在两方面保证了连接的安全性：

- 连接是私密的。协议使用对称加密算法（例如AES，RC4等）加密数据。每个连接使用的对称加密的Key是唯一生成的，并且使用另一个协议（例如TLS握手协议）来加密传输。记录协议也可以不加密使用。

- 连接是可靠的。消息在传输过程中会使用keyed MAC进行完整性检验。MAC计算使用安全的hash函数（例如SHA-1等等）。记录协议操作可以没有MAC，但通常只有另一个协议正在使用记录协议进行安全参数的交换时使用这种模式。

TLS记录协议用于封装某些更高层次的协议。TLS握手协议就是这样一种封装后的协议，它允许服务端和客户端验证对方的真实性和在传输第一个字节的数据前交换加密算法和加密key。TLS握手协议在三个方面保证连接的安全性。

- 各端的身份使用非对称的或者公钥算法（例如RSA，DSA等等）进行真实性检验。这种身份校验是可选的，但通常至少一方需要进行这种校验。

- 协商共享秘钥的过程是安全的：交换的秘钥对窃听者是不可用的，且任何未识别的连接无法获取秘钥，即使是一个能够把自己放到连接之间的攻击者也无法获取。

- 协商的过程是可靠的：没有攻击者能够在不被连接各方侦察到的情况下修改协商通信。

TLS的一大优势是它独立于应用层协议，更高层的协议可以透明的构建在TLS之上。然而，TLS协议并不会指定如何用协议来增强安全性，如何初始化TLS握手和如何解析交换的身份认证证书依赖于协议的设计者和实现者去决断。

## 1.1. 需要知道的术语

此文档中的术语 “MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，"RECOMMENDED"，“MAY”和“OPTIONAL”在[RFC 2119](https://www.rfc-editor.org/rfc/rfc2119)中做了解释。

## 1.2. 和TLS1.1版的主要差异

此文档是TLS 1.1协议的修订版，提升了协议的灵活性，尤其是对加密算法的协商过程。主要的差异点有：

- MD5/SHA-1组合的伪随机数函数（PRF）已经被加密套件指定的PRFs替换。此文档中的所有加密套件都是使用P_SHA256。

- 数字签名元素中MD5/SHA-1的组合已经被一个单独的hash函数取代，签名元素现在包括一个字段明确指定所使用的hash算法。

- 大量削减客户端和服务端指定hash算法和签名算法的能力操作能够指定使用何种hash算法和签名算法。注意这样也会放开一些之前版本签名算法和hash算法的限制

- 增加更多的数据模式来支持基于身份验证的加密。

- 扩展的定义和AES加密套件从第三方（TLSEXT和TLSAES）合并过来。

- 更严格的检查EncryptedPreMaster的版本号。

- 一些要求更加的严格。

- 数据长度校验现在依赖于加密套件（默认的仍是 12）。

- 删除了对Bleichenbacher/Klima攻防的描述。

- 很多场景下现在必须发送报警。

- 证书请求发起之后，如果没有可用的证书，客户端必须发送一个空证书列表。

- 使用TLS_RSA_WITH_AES_128_CBC_SHA算法实现加密套件是现在的强制要求。

- 增加HMAC-SHA256加密套件

- 移除IDEA和DES加密套件。它们现在已经过时了，并且会在一个单独的文档中描述。

- 对SSLv2版hello的向后兼容现在是MAY而不是SHOULD，而发送SSLv2版hello现在是SHOULD NOT。对它的支持将来也可能会变成SHOULD NOT。

- 增加了限制性的“fall-through”语法到表现语言中以便允许不同的情况有相同的编码。

- 增加了一个实现危险系数的章节。

- 一般性的说明和编辑工作。

## 2. 协议的目标

TLS协议的目标，按优先级排序如下：

    1. 加密的安全性：TLS应该用于双方建立安全的连接。

    2. 互操作性：独立的程序员应该能够使用TLS来开发应用程序，并且在不知道另一个人的代码的前提下成功的能与之交换参数。

    3. 可扩展性：TLS寻求实现一种框架，以便需要时能够方便的添加进来新的公钥和批量加密方法。这包括实现两个子目标：防止产生创建新协议的需要（并冒着产生新缺陷的风险）和避免实现一个新的完整的安全库。

    4. 相对的高效：加密操作相对是高CPU密集型的工作，尤其是公钥加密。因此，TLS协议已经支持了一个可选的会话缓存机制来减少创建连接的次数。此外，我们还把关注点放到了减少网络事件上。

## 3. 此文档的目标

此文档和TLS协议本身基于由网景公司发布的SSL 3.0协议说明发展而来。此协议和SSL 3.0协议之间的差距并不显著，但是差异也足够让TLS和SSL 3.0之间无法互相兼容（尽管每种协议都支持降级到前一个版本的机制）。本文档主要面向想要实现协议的读者和对协议做加密分析的用户。此说明书也是用这种思路来编写，且打算实现两组人不同的需求。为此，很多算法相关的数据结构和规则正文中（和附录相对），提供了更加容易的访问方式。

此文档并不打算提供任何服务定义或接口定义相关的详情。尽管它的确包含了策略的选择，但这是保持健壮的安全性的需要。

## 4. 表示语言

此文档使用一种外部的表示法来表示数据格式。接下来这种非常基础和有点随意定义的表示法将会使用。这种语法在结构上有几种来源。尽管它在语法上和编程语言“C”很相似，在XDR上和“C”的语法和缩进都很相似，借鉴太多相似的东西可能是一个风险。这种表示语言的目的仅仅局限于TLS文档；并没有超出特定目标的一般性的应用。

## 4.1. 基础数据块大小

所有数据项的表示是明确指定的。基础的数据块大小是1字节（也就是8位）。多字节数据项由多字节来组合，从左至右，从上到下。在字节流中，一个多字节的数据项（以数字为例）组合如下（使用C表示）:
```c
value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) | ... | byte[n-1];
```

这种多字节值的字节序就是常见的网络字节序或者叫大端法。

## 4.2. 其他约定

注释以“/\*”开始和“\*/”结束。

可选的组成部分用双括号“[[]]”括住来表示。

单字节没有特定含义的实体被认为是不透明的数据类型。

## 4.3. 向量

向量（一维数组）是一系列同类型的数据的流。向量的大小可能在代码编写阶段指定也可能在运行阶段才指定。另一方面，长度是指向量中字节的数量，而不是元素的数量。指定一种固定长度的数据类型为T的向量T'的语法是：

```
T T'[n];
```

这里，T'占用数据流中的n个字节，n是类型T大小的倍数。向量的长度不包括在数据流编码中。

在接下来的这个例子里，Datum被定义成三个连续字节的不被协议解释的数据类型，而Data由三个连续的Datum数据类型组成，一共9个字节。

```
opaque Datum[3];      /* 三个没有特定含义的字节 */
Datum Data[9];        /* 3个连续的3字节向量 */
```

变长向量通过指定一个合法的长度范围（包括边界在内）来定义，使用记号<floor..ceiling>。当编码这种数据时，字节流在传输向量的实际内容之前，会传输向量的长度。保存长度所需的字节以存储向量指定的最大（上限）长度所需的字节为准。实际长度指定为0的变长向量被认为是空向量。

```
T T'<floor..ceiling>;
```

在下面这个例子中，mandatory是一个必须包含300到400字节的opaque类型数据的向量，它不能为空。它的实际长度需要两个字节的uint16来表示，这足够存储值400了（查看4.4节）。另一方面，longer可以表示到800字节的数据，或者400个uint16元素，它可以为空。向量编码的头部将会添加两个字节的字段表示实际长度。编码后的向量必须是单个元素长度的偶数倍（例如，17字节的uint16类型的向量是不合法的）。

```
opaque mandatory<300..400>;    /* 表示长度的字段为2个字节，不能为空 */
uint16 longer<0..800>;         /* 0到400个 16bit的 无符号整数 */
 ```

 ## 4.4. 数字

 基本的数字数据类型是无符号的byte（uint8）。更大的其他数字数据类型由固定长度的一系列byte串接组成，正如4.1节中所介绍的，它们同样是无符号的。预定义了以下几种数据类型：

```
uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];
```

本文档的所有值，都是用网络字节序（大端法）来存储的；用十六进制01 02 03 04表示的uint32和十进制的数16909060相等。

注意在某些场景下（例如DH参数）需要使用opque向量来表示整数。在这种场景下，它们被当做无符号的整形（例如，即使设置了最高有效位，0开头的八进制也是不必要的）。

## 4.5. 枚举

另一种支持的较少出现的数据类型叫做枚举。枚举类型的值仅仅能够使用定义时声明的值。每一次定义都是不同的类型。只有相同类型的枚举值才能够相互赋值和比较。枚举中的每个元素必须赋值，如下面所示的例子。由于枚举值的元素是无序的，它们能够以任何顺序赋任何值。

```
enum {e1(v1), e2(v2), ... , en(vn) [[, (n)]]} Te;
```

枚举值在字节流中占用的空间和它的最大序列值相同。下面的定义将会使用1个字节来保存类型Color中的字段。

```
enum { red(3), blue(5), white(7) } Color;
```

枚举可以指定一个没有相关联的tag的值来强制定义宽度，从而可以避免定义一个不必要的元素。

在下面的这个例子中，Taste会占用数据流中的两个字节，但是只能赋值1，2或4。

```
enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

枚举值元素的名称需要带上所在的枚举类型名称，在第一个例子中，对Color第二个元素的完全限定引用的写法是Color.blue。如果赋值的目标已经指定了类型，这种限定可以省略。

```
Color color = Color.blue;   /* 重复指定，是合法的 */
Color color = blue;         /* 正确，隐式类型指定 */
```

对于从来不会转换成外部表示的枚举，其中的数字信息是可以省略的。

```
enum { low, medium, high } Amout;
```

## 4.6. 结构化的类型

结构体可以由简单数据类型构造而成。每种规格会定义一个新的，独一无二的类型。定义的语法和C语言非常的类似。

```
struct {
  T1 f1;
  T2 f2;
  ...
  Tn fn;
} [[T]]
```

一个结构体中的字段可以使用类型名称来引用，和枚举的使用语法非常类似。例如，T.f2指向上面定义中的第二个字段。

结构体的定义支持嵌套。

## 4.6.1. 变体

定义结构体时可能会存在根据当前环境已知信息的变体。选择器必须是一个定义了结构体可能值的枚举类型。select中定义的枚举的每个元素都应该有一个case选项和它对应。case选项能够包含有限制的fall-through：如果两个case选项紧挨着并且之间没有字段的话，那么它们则包含相同的字段。因此，在下面的例子中，“orange”和“banana”同时包含V2。注意这是TLS 1.2协议中的新语法。

变体结构的内容可以用一个符号来引用。变体选项的确定在在运行时确定而不是在语言定义时。

```
struct {
  T1 f1;
  T2 f2;
  ....
  Tn fn;
   select (E) {
      case e1: Te1;
      case e2: Te2;
      case e3: case e4: Te3;
      ....
      case en: Ten;
   } [[fv]];
} [[Tv]];
```

例如：

```
  enum { apple, orange, banana } VariantTag;

  struct {
    uint16 number;
    opaque string[0..10]; /* 变长 */
  } V1;

  struct {
    uint32 number;
    opaque string[10];  /* 固定长度 */
  } V2;

  struct {
    select (VariantTag) { /* 选择器的值是隐式的 */
      case apple:
        V1;  /* 变体内容, tag = apple */

      case orange:
      case banana:
        V2;  /* 变体内容，tag = orange 或 banana */    
    } variant_body;  /*变体中可选的标识*/
  } VariantRecord;
```

## 4.7.1. 加密属性

五种加密操作 - 数字签名，流式加密，块式加密，使用额外数据的授权加密（AEAD）和公钥加密，这些分别被设计成数字签名的，流式加密的，块式加密的， AEAD加密的和公钥加密的。一个字段的加密处理通过前置一个合适的关键词。加密key有当前session状态（查看第6.1节）。

一个数字签名的元素被当做结构体DigitallySigned来处理：
```
struct {
  SignatureAndHashAlgorithm algorithm;
  opaque signature<0..2^16-1>;
} DigitallySigned;
```

algorithm字段指定使用的算法（查看第7.4.1.4.1节来了解此字段的定义）。注意算法字段的介绍已经和以前的版本不一样。signature字段是一个用这些算法在元素内容上计算出来的。内容本身没有出现在报文中而是简单的进行计算。签名的长度受算法和key的长度决定。
